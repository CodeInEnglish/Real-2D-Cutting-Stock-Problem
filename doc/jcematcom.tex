%===================================================================================
% JORNADA CIENTÍFICA ESTUDIANTIL - MATCOM, UH
%===================================================================================
% Esta plantilla ha sido diseñada para ser usada en los artículos de la
% Jornada Científica Estudiantil, MatCom.
%
% Por favor, siga las instrucciones de esta plantilla y rellene en las secciones
% correspondientes.
%
% NOTA: Necesitará el archivo 'jcematcom.sty' en la misma carpeta donde esté este
%       archivo para poder utilizar esta plantila.
%===================================================================================



%===================================================================================
% PREÁMBULO
%-----------------------------------------------------------------------------------
\documentclass[a4paper,10pt,twocolumn]{article}

%===================================================================================
% Paquetes
%-----------------------------------------------------------------------------------
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{jcematcom}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[pdftex]{hyperref}
%-----------------------------------------------------------------------------------
% Configuración
%-----------------------------------------------------------------------------------
\hypersetup{colorlinks,%
	    citecolor=black,%
	    filecolor=black,%
	    linkcolor=black,%
	    urlcolor=blue}

%===================================================================================



%===================================================================================
% Presentacion
%-----------------------------------------------------------------------------------
% Título
%-----------------------------------------------------------------------------------
\title{Modelos de Optimización II \\
	Al desperdicio, ¡ni un tantico así!}

%-----------------------------------------------------------------------------------
% Autores
%-----------------------------------------------------------------------------------
\author{\\
\name Dalianys Pérez Pereira \email \href{mailto:a.uno@lab.matcom.uh.cu}{a.uno@lab.matcom.uh.cu}
	\\ \addr Grupo C411 \AND
\name Dayany Alfaro González \email \href{mailto:d.alfaro@matcom.uh.cu}{d.alfaro@matcom.uh.cu}
  \\ \addr Grupo C411 \AND
\name Gilberto González Rodríguez \email \href{mailto:a.dos@lab.matcom.uh.cu}{a.dos@lab.matcom.uh.cu}
\\ \addr Grupo C411 \AND
\name Antonio Jesús Otaño Barrera \email \href{mailto:a.dos@lab.matcom.uh.cu}{a.dos@lab.matcom.uh.cu}
\\ \addr Grupo C411}

%-----------------------------------------------------------------------------------
% Tutores
%-----------------------------------------------------------------------------------
%\tutors{\\
%Dr. Tutor Uno, \emph{Centro} \\
%Lic. Tutor Dos, \emph{Centro}}

%-----------------------------------------------------------------------------------
% Headings
%-----------------------------------------------------------------------------------
%\jcematcomheading{\the\year}{1-\pageref{end}}{A. Uno, A. Dos}

%-----------------------------------------------------------------------------------
%\ShortHeadings{Autores}
%===================================================================================



%===================================================================================
% DOCUMENTO
%-----------------------------------------------------------------------------------
\begin{document}

%-----------------------------------------------------------------------------------
% NO BORRAR ESTA LINEA!
%-----------------------------------------------------------------------------------
\twocolumn[
%-----------------------------------------------------------------------------------

\maketitle

%===================================================================================
% Resumen y Abstract
%-----------------------------------------------------------------------------------
\selectlanguage{spanish} % Para producir el documento en Español

%-----------------------------------------------------------------------------------
% Resumen en Español
%-----------------------------------------------------------------------------------
\begin{abstract}

	El Resumen en Español debe constar de $100$ a $200$ palabras y presentar de forma
	clara y concisa el contenido fundamental del artículo.

\end{abstract}

%-----------------------------------------------------------------------------------
% English Abstract
%-----------------------------------------------------------------------------------
\vspace{0.5cm}

\begin{enabstract}

  The English Abstract must have have $100$ to $200$ words, and present in a clear
  and concise form the essentials of the article content.

\end{enabstract}

%-----------------------------------------------------------------------------------
% Palabras clave
%-----------------------------------------------------------------------------------
\begin{keywords}
	Separadas,
	Por,
	Comas.
\end{keywords}

%-----------------------------------------------------------------------------------
% Temas
%-----------------------------------------------------------------------------------
\begin{topics}
	Tema, Subtema.
\end{topics}


%-----------------------------------------------------------------------------------
% NO BORRAR ESTAS LINEAS!
%-----------------------------------------------------------------------------------
\vspace{0.8cm}
]
%-----------------------------------------------------------------------------------


%===================================================================================

%===================================================================================
% Introducción
%-----------------------------------------------------------------------------------
\section{Introducción}\label{sec:intro}
%-----------------------------------------------------------------------------------
El problema de patrones de corte de piezas rectangulares pertenece a
la familia de problemas de corte y empaquetamiento y sus
aplicaciones se pueden observar en industrias de perfiles
metálicos, corte de maderas, papel, plástico o vidrio en
donde los componentes rectangulares tienen que ser
cortados de grandes hojas de material. Para estas industrias es de gran importancia realizar
este proceso de corte de una manera eficiente buscando
minimizar el desperdicio y los demás costos asociados
al proceso, teniendo en cuenta las restricciones técnicas
y de demanda. 



El problema de patrones de corte es un problema de gran
complejidad tanto por las características y variables
que involucra como por las técnicas que se utilizan
para abordarlo, es una temática en constante evolución
y muchos investigadores han desarrollado diversos
modelos para resolverlo. El interés en este problema
puede ser sustentado por su aplicación práctica y el
reto que representa pues, en general,
es computacionalmente difícil de resolver ya que es un
problema de tipo NP-completo, dado que los patrones de
empaquetamiento incrementan exponencialmente con el
número de rectángulos que deben ser empaquetados. 
 
Este trabajo tiene como objetivo resolver un problema de corte en dos dimensiones, asociado a la industria del papel, presente en una empresa ubicada en la provinicia Pinar del Río, Cuba. Se propone el  diseño e implementación de un algoritmo que permita determinar qué patrones de corte deben usarse para cortar un conjunto de hojas de forma que se satisfaga una demanda (de hojas más pequeñas) solicitada por el usuario de forma que el desperdicio resultante de los cortes sea el menor posible. En este caso se permite la rotación de las piezas a colocar y se requiere que los cortes sean de tipo guillotina, es decir, que  el corte vaya de un extremo a otro del rectángulo original. 

La solución propuesta está implementada haciendo uso de Python como lenguaje. Además se brinda como parte de la solución una aplicación de escritorio con una interfaz de usuario para introducir una instancia del problema en cuestión. 

[Texto explicando lo que aborda cada sección]

%===================================================================================

\section{Antecedentes y Enfoques de Solución}
El Problema de patrones de corte (CSP, por sus siglas
en inglés) fue formulado por primera vez en 1939
por el economista ruso Kantorovich.

Han surgido numerosas investigaciones que abordan
diferentes problemas según el tipo de dimensión (1D y
2D) y desde diversos enfoques tales como los métodos
exactos, heurísticos y meta heurísticos, pero aún no
existe un método global establecido para dar solución
a este tipo de problemas, debido a la complejidad
asociada. 

\subsection{Programación Lineal Entera}

Casi todos los procedimientos basados en la
programación lineal para resolver el problema de
patrones de corte se remontan a Gilmore y Gomory,
\cite{1}, para lo cual, proponen la relajación de la restricción
de integridad para la solución de problemas de
programación lineal logrando minimizar el desperdicio
a través de la generación de columnas evitando el
conocimiento explícito o enumeración de todos los
patrones desde el principio, ya que bajo este esquema
las columnas (patrones) son generadas cuando se
requieran \cite{2}. La idea consiste en utilizar el método
simplex revisado para resolver el problema de la entrada
del patrón de corte siguiente a la base mediante la
resolución de un problema de la mochila asociado. Este
método es denominado en la literatura como \textit{delayed
column generation technique}, y permite resolver este
tipo de problemas en un tiempo computacional mucho
menor \cite{3}.


\subsection{Procedimientos Heurísticos Secuenciales}
Los procedimientos heurísticos secuenciales pertenecen
a la clase de heurísticas de búsqueda local. La solución
se construye mediante la generación de patrones uno
a uno hasta que todos los requerimientos de demanda
se hayan satisfecho, donde los patrones inicialmente
seleccionados deben tener un nivel de desperdicio
bajo, un nivel de utilización alto y dejar una serie de requerimientos para poder combinar bien los patrones
futuros, evitando así incurrir posteriormente en
desperdicios excesivos \cite{3}. La ventaja principal de este método es que puede controlar otros factores aparte del desperdicio y elimina
el problema del redondeo al trabajar sólo con valores
enteros.

\subsection{Procedimientos Heurísticos Híbridos }
Este procedimiento consiste en combinar los dos
procedimientos descritos anteriormente, de tal forma
que se utilice el procedimiento heurístico secuencial
para generar una solución, la cual es guardada y
utilizada como base inicial en el procedimiento de
programación lineal. Posteriormente, el desperdicio es
reducido si es posible a través iteraciones adicionales,
tal y como lo realiza \cite{41}. 

Independientemente de la forma como
se combinen estos dos métodos, lo más importante
del éxito de la unión entre el procedimiento heurístico
secuencial y el redondeo de problemas de programación
lineal es la selección del criterio apropiado para resolver
el problema \cite{29}.

\subsection{ Metaheurísticas }
Ante el problema que presenta la búsqueda local y
las heurísticas constructivas de quedar atrapadas en
óptimos locales, surgen las metaheurísticas a mediados
de 1970 pues tienen la capacidad de guiar la búsqueda
local para que se escape de los óptimos locales. Muchos
de estos algoritmos se han utilizado para resolver
el problema de patrones de corte, entre los cuales
se destaca \textit{Tabu Search} (TS), \textit{Greedy Randomized
Adaptive Search Procedure} (GRASP) \cite{42}, Algoritmos
genéticos \cite{43,46} y \textit{Ant Colony Optimization} (ACO) \cite{47,48}, entre otros algoritmos evolucionarios \cite{51}.

%===================================================================================
% Desarrollo
%-----------------------------------------------------------------------------------
\section{Definición del Problema}
Sea $I$ el conjunto de $n$ hojas, una hoja $i$ está definida por su ancho $w_i$, su altura $h_i$ y su demanda $d_i$. Sea $J$ el conjunto de $m$ patrones de corte con las mismas dimensiones $H \times W$, el número $m$ es desconocido. Sea $p_{ji}$ el número de hojas $i$ presentes en el patrón $j$, se tiene que $p_j = (p_{j1},...,p_{jn})$. Sea $\pi_j$ una configuración de las hojas del patrón $j$, la cual incluye información acerca de la posición exacta de las hojas y si se encuentran rotadas o no. Por tanto, un patrón $j$ va a estar definido por $(p_j,\pi_j)$. Sea $x_j$ el número de veces que es necesario aplicar el patrón de corte $j$, se tiene que las variables de decisión son: $m, p_j, x_j$ y $\pi_j$ $\forall j \in J$.  

El objetivo que se persigue es minimizar el desperdicio de papel:
\begin{equation}
f = \sum_{j \in J}c_j x_j
\label{eq1}
\end{equation}
donde $c_j$ es el área no usada del patrón $j$.

Para satisfacer la demanda $d_i$ solicitada para cada hoja $i$ van a aparecer $n$ restricciones:
\begin{equation}
\sum_{j \in J}p_{ji}x_j \geq  d_i \ \  \forall i \in I
\label{eq2}
\end{equation}

Es necesario también tener en cuenta la sobreproducción a la hora de analizar el espacio desperdiciado dado que cuando una solución sobrecumple la demanda se tiene que esas hojas sobreproducidas también van a ser desechadas. Por tanto para tener lo anterior en consideración hay modificar la función objetivo que se muestra en la ecuación \eqref{eq1}. Sea $a_i$ el área total de la hoja $i$ se tiene que:
 $$sobreProd = \sum_{i \in I} sobreProd_i $$ 
donde $sobreProd_i = (\sum_{j \in J} p_{ji}x_ja_i)  -  d_ia_i$ va a ser el número de hojas $i$ sobreproducidas.
La nueva función objetivo sería la siguiente:
\begin{equation}
f = \sum_{j \in J}c_j x_j + sobreProd
\label{eq3}
\end{equation}

Esta función objetivo y las $n$ restricciones presentadas antes definen un problema de programación lineal entero. Sea $S$ el conjunto de todas las posibles soluciones, una solución $s \in S$ va a estar formada por $((p_1,\pi_1),...,(p_m,\pi_m))$ y $(x_1,...,x_m)$ que es la solución de dicho problema lineal entero.


\section{Propuesta de Solución}
La solución que se propone en este trabajo es una adaptación de la solución brindada por \cite{4}. El problema de patrones de cortes va a ser dividido en los siguientes 3 subproblemas de optimización:
\begin{enumerate}
	\item El problema de programación lineal descrito en la sección anterior, el cual consiste en hallar $(x_1,...,x_m)$.
	\item Un problema de empaquetamiento en 2 dimensiones (2D Bin Packing) que consiste en encontrar las configuraciones $(\pi_1,...,\pi_m)$ de las hojas en los $m$ patrones.
	\item Un problema combinatorio que consiste en hallar los adecuados $(p_1,...,p_m)$. Para resolverlo se utiliza un algoritmo genético, el cual a su vez se va a apoyar en los subproblemas anteriores. 
\end{enumerate}

\subsection{Problema de Programación Lineal}
Como ha sido explicado en la Sección 3 es necesario resolver un problema de programación lineal entero donde se quiere minimizar la función que se muestra en la ecuación \eqref{eq3} sujeta a las restricciones en la ecuación \eqref{eq2}.

La eficiencia al resolver este subproblema resulta crucial debido a que va ser necesario resolverlo múltiples veces para evaluar y saber cuan buenas son las soluciones al problema de patrones de corte que se van obteniendo. Por esto se resuelve el problema relajado correspondiente por lo que la solución obtenida $({x_1}^*,...,{x_m}^*)$ se redondea de forma que el número de veces que es necesario aplicar el patrón de corte $x_j = \lceil {x_j}^* \rceil \ \ \forall j \in J$.

Dado que en el presente trabajo se usó Python como lenguaje, para resolver esta fase del problema se exploraron las herramientas que brinda dicho lenguaje para resolver problemas de programación lineal y se decidió hacer uso de la biblioteca \texttt{cvxopt}.

\subsection{2D Bin Packing}
El problema 2D Bin Packing se puede enunciar de la siguiente manera: Dada una lista de rectángulos $(R_1,...,R_n)$ determinar la forma de colocarlos todos sin que se solapen y usando el menor número posible de contenedores rectangulares (\textit{bins}). En este caso los rectángulos serían las hojas que se demandan y un \textit{bin} sería la hoja a picar. Como resultado se obtendría una lista de patrones $\pi = (\pi_1,...,\pi_k)$.

Existen diversas alternativas para resolver este problema \cite{11}. En este caso se propone la variante \textit{Guillotine}, que como su nombre indica cumple la restricción de cortes tipo guillotina. Este algoritmo en todo momento mantiene actualizada una lista "rectángulos libres" que representan el área disponible en el rectángulo principal(\textit{bin}). Estos rectángulos libres cumplen que son disjuntos tomados dos a dos, es decir $F_i \cap F_j = \emptyset \ \ \forall i\neq j $ y el área libre total del \textit{bin} se puede definir como $\bigcup\limits_{i=1}^{m} F_{i}$ donde $F = \{F_1,...,F_m\}$ es la lista de rectángulos libres. El algoritmo comienza con un único rectángulo libre, lo cual se representa como $F = \{F_1 = (W \times H)\}$. En cada iteración del algoritmo se selecciona un rectángulo libre $F_i$ donde coloca el rectángulo $R = (w \times h)$ en la esquina inferior izquierda, por tanto $F_i$ se sustituye por dos nuevos rectángulos $F',F''$ que cumplen que $F' \cap F'' = \emptyset$ y $F' \cup F'' \cup R = F_i$. Este procedimiento continúa hasta que se hayan colocado todos los rectángulos.

En la implementación del algoritmo \textit{Guillotine} se usaron las siguientes heurísticas:
\begin{itemize}
	\item \textbf{BSSF:} \textit{Best Short Side Fit}\\
	A la hora de escoger un rectángulo libre de $F = \{F_1,...,F_m\}$ para colocar el rectángulo $R = (w \times h)$ se selecciona el $F_i = (w_i \times h_i)$ tal que $min(w_i-w,h_i-h)$ tiene el menor valor. 
	\item \textbf{BFF:} \textit{Bin First Fit}\\
	Como se pueden tener varios \textit{bins} abiertos a la vez se decide colocar $R = (w \times h)$ en el primer \textit{bin} en el que quepa.
	\item \textbf{SAS:} \textit{Shorter Axis Split}\\
	Cuando se va a sustituir $F_i$ por $F',F''$ se realiza un corte paralelo al lado más pequeño de $F_i$.
	\item \textbf{DESCSS:} \textit{Sort by Shorter Side First in Descending Order}\\
	Ordenar la entrada $(R_1,...,R_n)$ de acuerdo al siguiente criterio:
	$$R_i < R_j \Longleftrightarrow min(w_i,h_i) < min (w_j,h_j)$$ 
	\item \textbf{RM:} \textit{Rectangle Merge}\\
	La principal limitante del algoritmo es que a causa de mantener una lista de rectángulos libres disjuntos es posible que no permita colocar un rectángulo aún cuando hay suficiente área libre para ello. Una manera en la que se puede mejorar el algorito es después de colocar un rectángulo encontrar todos los pares de rectángulos libre vecinos que pueden ser mezclados en uno solo y mezclarlos. Repetir este procedimiento mientras exista al menos un par de rectángulos libres $F_i, F_j$ que cumplan dicha condición.
\end{itemize}

\subsection{Algoritmo Genético}

Los algoritmos genéticos son llamados así porque se inspiran en la evolución biológica y su base genético-molecular. Estos algoritmos hacen evolucionar una población de individuos sometiéndola a acciones aleatorias semejantes a las que actúan en la evolución biológica (mutaciones y recombinaciones genéticas), así como también a una selección de acuerdo con algún criterio, en función del cual se decide cuáles son los individuos más adaptados, que sobreviven, y cuáles los menos aptos, que son descartados.\cite{5}

El funcionamiento de un algoritmo genético básico se puede resumir en los pasos siguientes:
\begin{itemize}
	\item \textbf{Inicialización}: Se genera aleatoriamente la población inicial, que está constituida por un conjunto de cromosomas los cuales representan las posibles soluciones del problema. En caso de no hacerlo aleatoriamente, es importante garantizar que dentro de la población inicial, se tenga la diversidad estructural de estas soluciones para tener una representación de la mayor parte de la población posible o al menos evitar la convergencia prematura.
	\item \textbf{Evaluación}: A cada uno de los cromosomas de esta población se aplicará la función de aptitud para saber cómo de "buena" es la solución que se está codificando.
	\item \textbf{Condición de término}: El AG se deberá detener cuando se alcance la solución óptima, pero esta generalmente se desconoce, por lo que se deben utilizar otros criterios de detención. Normalmente se usan dos criterios: correr el AG un número máximo de iteraciones (generaciones) o detenerlo cuando no haya cambios en la población. Mientras no se cumpla la condición de término se hace lo siguiente:
	\begin{itemize}
		\item \textbf{Selección}: Después de saber la aptitud de cada cromosoma se procede a elegir los cromosomas que serán cruzados en la siguiente generación. Los cromosomas con mejor aptitud tienen mayor probabilidad de ser seleccionados.
		\item \textbf{Recombinación o cruzamiento}: La recombinación es el principal operador genético, representa la reproducción sexual, opera sobre dos cromosomas a la vez para generar dos descendientes donde se combinan las características de ambos cromosomas padres.
		\item \textbf{Mutación}: Modifica al azar parte del cromosoma de los individuos, y permite alcanzar zonas del espacio de búsqueda que no estaban cubiertas por los individuos de la población actual.
		\item \textbf{Reemplazo}: Una vez aplicados los operadores genéticos, se seleccionan los mejores individuos para conformar la población de la generación siguiente. \cite{5}
	\end{itemize}
\end{itemize}


\section{Desarrollo}\label{sec:dev}
%-----------------------------------------------------------------------------------
  En esta sección (o secciones) incluya el contenido fundamental del artículo.
  No es necesario tener una sección nombrada \emph{Desarrollo}, por el contrario,
  nombre las secciones según el contenido que tratan.

%-----------------------------------------------------------------------------------
	\subsection{Organización del Documento}\label{sub:results}
%-----------------------------------------------------------------------------------
		Puede agregar secciones y subsecciones según sea necesario para organizar
		de manera más coherente su artículo. Tenga en cuenta que un documento más
		plano es más fácil de navegar y entender, pero las subsecciones relacionadas
		deberían estar agrupadas en una sección común.

		Los nombres de las secciones deben ir en mayúsculas, excepto para las
		preposiciones, conjunciones, y otros vocablos auxiliares.

		Empiece un nuevo párrafo cada vez que vaya a comenzar una idea nueva.

%-----------------------------------------------------------------------------------
	\subsection{Listas y Descripciones}\label{sub:lists}
%-----------------------------------------------------------------------------------
		Para producir listas enumeradas, use el siguiente estilo:

%-----------------------------------------------------------------------------------
		\begin{enumerate}
			\item Primer Elemento
			\item Segundo Elemento
			%
			\begin {enumerate}
				\item {Segundo Elemento - Subitem Uno}
				\item {Segundo Elemento - Subitem Dos}
			\end {enumerate}
			%
		\end{enumerate}

%-----------------------------------------------------------------------------------
		Para producir descripciones, use el siguiente estilo:

%-----------------------------------------------------------------------------------
		\begin{description}
			\item [Primer Elemento] con su respectiva descripción.
			\item [Segundo Elemento] también con su respectiva descripción.
		\end{description}

%-----------------------------------------------------------------------------------
	\subsection{Figuras}\label{sub:figures}
%-----------------------------------------------------------------------------------
		Para producir cuerpos flotantes (figuras ó tablas), asegúrese de numerar
		y etiquetar correctamente cada figura. Las referencias a las figuras deben
		estar también correctamente etiquetadas. Por ejemplo, en la Fig. \ref{fig:ex}
		se muestra\ldots.

		\begin{figure}[htb]%
		\begin{center}
			\emph{Aquí va el contenido de la figura \ldots}
		\end{center}
		\caption{Figura de ejemplo \label{fig:ex}}%
		\end{figure}

%-----------------------------------------------------------------------------------
	\subsection{Código Fuente}\label{sub:listings}
%-----------------------------------------------------------------------------------
		Para producir código fuente, envuélvalo en una figura flotante y
		etiquételo correctamente. Por ejemplo, en la Fig. \ref{fig:code}
		se muestra un código bastante conocido\ldots.

		% Configuración de Listings
		\lstset{keywordstyle=\color{blue}, basicstyle=\small}

		\begin{figure}[htb]%
			\begin{lstlisting}[language=c]%

    int main(int argc, char** argv)
    {
        // Imprimiendo "Hola Mundo".
        printf("Hello, World");
    }

			\end{lstlisting}
		\caption{Código fuente de ejemplo.\label{fig:code}}
		\end{figure}

%-----------------------------------------------------------------------------------
	\subsection{Referencias}
%-----------------------------------------------------------------------------------
  	Las referencias deben estar agrupadas en una sección al final del artículo,
  	y las citas numeradas correctamente, por ejemplo \cite{knuth} ó \cite{goedel}.
  	Incluya toda la información importante de cada referencia, incluídos autor,
  	título, y notas de la edición. En caso de citar sitios web, además
  	de la URL, incluya la fecha en que fue consultado, como en \cite{wiki}.

%===================================================================================



%===================================================================================
% Conclusiones
%-----------------------------------------------------------------------------------
\section{Conclusiones}\label{sec:conc}

  En esta sección puede incluir las conclusiones de su investigación y las ideas
  sobre la continuidad del trabajo, en el caso que aplique.

%===================================================================================



%===================================================================================
% Recomendaciones
%-----------------------------------------------------------------------------------
\section{Recomendaciones}\label{sec:rec}

  En esta sección puede incluir recomendaciones sobre posibles formas de continuar
  la investigación u otros temas relacionados.

%===================================================================================



%===================================================================================
% Bibliografía
%-----------------------------------------------------------------------------------
\begin{thebibliography}{99}
%-----------------------------------------------------------------------------------
	\bibitem{1} P. Gilmore, and R. Gomory, “A linear programming
	approach to the Cutting Stock Problem-Part II,”
	Operations Research, 11(6), 863-888, 1963.
	
	\bibitem{2} H. Hideki, and M.J. Pinto, “An integrated cutting
	stock and sequencing problem,” European Journal of
	Operational Research (183), 1353–1370, 2007.
	
	\bibitem{3}J. Karelahti, “Solving the cutting stock problem in
	the steel industry”. Department of Engineering Physics
	and Mathematics. Helsinki University of Technology,
	2-5, 2002.
	
	\bibitem{4} Stéphane Bonnevay, Philippe Aubertin, and Gérald Gavin, "A Genetic Algorithm to Solve a Real 2-D Cutting Stock
	Problem with Setup Cost in the Paper Industry". Genetic and Evolutionary Computation Conference,2015
	
	\bibitem{11} J. Jylanki. A thousand ways to pack the bin - a
	practical approach to two-dimensional rectangle bin
	packing. research report, 2010.
	
	\bibitem{41}  Cui, Y.-P., Tang, T.-B. Parallelized sequential value correction procedure for the one-dimensional cutting
	stock problem with multiple stock lengths. Engineering
	Optimization, 46 (10), 1352-1368, 2014.
	
	\bibitem{29} R. Haessler, and P. Sweeney, “Cutting stock
	problems and solution procedures,” European Journal
	of Operational Research, 54, 141-150, 1991.
	
	\bibitem{42} MirHassani, S.A., Jalaeian Bashirzadeh, A. A
	GRASP meta-heuristic for two-dimensional irregular
	cutting stock problem. International Journal of
	Advanced Manufacturing Technology, 81 (1-4), 455-
	464, 2105.
	
	\bibitem{43}  Wenshu, L., Dan, M., Jinzhuo, W. Study on cutting
	stock optimization for decayed wood board based
	on genetic algorithm. Open Automation and Control
	Systems Journal, 7 (1), 284-289, 2015.
	
	\bibitem{46}  Lu, H.-C.a , Huang, Y.-H.b. An efficient genetic
	algorithm with a corner space algorithm for a cutting
	stock problem in the TFT-LCD industry. European
	Journal of Operational Research, 246 (1), 51-65, 2015.
	
	\bibitem{47}Lu, Q., Zhou, X. GPU parallel ant colony algorithm
	for the dynamic one-dimensional cutting stock problem
	based on the on-line detection. Yi Qi Yi Biao Xue Bao/
	Chinese Journal of Scientific Instrument, 36 (8), pp.
	1774-1782, 2015.
	
	\bibitem{48}  Díaz, D., Valledor, P., Areces, P., Rodil, J., Suárez, M.
	An ACO Algorithm to Solve an Extended Cutting Stock
	Problem for Scrap Minimization in a Bar Mill. Lecture
	Notes in Computer Science (including subseries Lecture
	Notes in Artificial Intelligence and Lecture Notes in
	Bioinformatics), 8667, 13-24, 2014.
	
	\bibitem{51} Ben Lagha, G.a , Dahmani, N.b , Krichen, S.a.
	Particle swarm optimization approach for resolving the
	cutting stock problem. 2014 International Conference
	on Advanced Logistics and Transport, 2014.
	
	\bibitem{5} Wikipedia. URL: \href{https://es.wikipedia.org/wiki/Algoritmo\_genetico}
	{https://es.wikipedia.org/wiki/Algoritmo\_genetico}.
	Consultado el 15 de Noviembre, 2020.
	
	\bibitem{knuth} Donald E. Knuth. \emph{The Art of Computer Programming}.
		Volume 1: Fundamental Algorithms (3rd~edition), 1997.
		Addison-Wesley Professional.

	\bibitem{goedel} Kurt Göedel. \emph{Über formal unentscheidbare Sätze der
		Principia Mathematica und verwandter Systeme, I}.
		Monatshefte für Mathematik und Physik 38.

	\bibitem{wiki} Wikipedia. URL: \href{http://en.wikipedia.org}
	  {http://en.wikipedia.org}.
		Consultado en \today.

%-----------------------------------------------------------------------------------
\end{thebibliography}

%-----------------------------------------------------------------------------------

\label{end}

\end{document}

%===================================================================================
